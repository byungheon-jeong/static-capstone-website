<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.15">
<link rel="alternate" type="application/rss+xml" href="/static-capstone-website/blog/rss.xml" title="Google Earth Engine Labeler RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/static-capstone-website/blog/atom.xml" title="Google Earth Engine Labeler Atom Feed"><title data-react-helmet="true">Prediction Model and Analyses | Google Earth Engine Labeler</title><meta data-react-helmet="true" property="og:title" content="Prediction Model and Analyses | Google Earth Engine Labeler"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" name="description" content="Author: Ivan Cano"><meta data-react-helmet="true" property="og:description" content="Author: Ivan Cano"><meta data-react-helmet="true" property="og:url" content="https://your-docusaurus-test-site.com/static-capstone-website/analysis/Final_Report_Updated"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_tag" content="default"><link data-react-helmet="true" rel="icon" href="/static-capstone-website/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://your-docusaurus-test-site.com/static-capstone-website/analysis/Final_Report_Updated"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/static-capstone-website/analysis/Final_Report_Updated" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://your-docusaurus-test-site.com/static-capstone-website/analysis/Final_Report_Updated" hreflang="x-default"><link rel="stylesheet" href="/static-capstone-website/assets/css/styles.d00dcd60.css">
<link rel="preload" href="/static-capstone-website/assets/js/runtime~main.21163b71.js" as="script">
<link rel="preload" href="/static-capstone-website/assets/js/main.a793c94e.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/static-capstone-website/"><div class="navbar__logo"><img src="/static-capstone-website/img/globe-eurafrica.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/static-capstone-website/img/globe-eurafrica.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title">Google Earth Engine Labeler</b></a><a class="navbar__item navbar__link" href="/static-capstone-website/docs/intro">Tutorial</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/static-capstone-website/analysis/Final_Report_Updated">Analysis</a><a class="navbar__item navbar__link" href="/static-capstone-website/about_us/MDAboutUs">About Us</a><a class="navbar__item navbar__link" href="/static-capstone-website/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/byungheon-jeong/google-eartheingine-labeler" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="toggle_Pssr toggle_TdHA toggleDisabled_jDku"><div class="toggleTrack_SSoT" role="button" tabindex="-1"><div class="toggleTrackCheck_XobZ"><span class="toggleIcon_eZtF">ðŸŒœ</span></div><div class="toggleTrackX_YkSC"><span class="toggleIcon_eZtF">ðŸŒž</span></div><div class="toggleTrackThumb_uRm4"></div></div><input type="checkbox" class="toggleScreenReader_JnkT" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mdx-wrapper mdx-page"><main class="container container--fluid margin-vert--lg"><div class="row mdxPageWrapper_zHyg"><div class="col col--8"><h1>Prediction Model and Analyses</h1><h3 class="anchor anchorWithStickyNavbar_mojV" id="author-ivan-cano">Author: Ivan Cano<a class="hash-link" href="#author-ivan-cano" title="Direct link to heading">â€‹</a></h3><h3 class="anchor anchorWithStickyNavbar_mojV" id="date-382022">Date: 3/8/2022<a class="hash-link" href="#date-382022" title="Direct link to heading">â€‹</a></h3><hr><p>With the turn of the 21st century, the world has seen advancements in medicine,
technology, and more equitable living standards in many parts of the world. And with this
increase of human population, also comes expansion into human development, much of it in the
form of housing and urban infrastructure. Although, in some cases, people may build settlements
unsanctioned by the state, and these people may suffer many vulnerabilities, including increased
crimes, and water and food insecurities in times of drought, natural disasters
Our team believes that tracking human development can prove useful in helping these people
that live on the fringes of society. By using satellite images, from the landsat 8 repository (a
NASA satellite image database), our team has created labeling service to be able to classify urban
settlement and expansion over periods of urban growth. In this markdown file we will be using information that we have gathered using our classification service on the Xiong An New District in Hebei, China to be able to accurately predict future growth by utiliying (machine learning) models. We hope that by creating an ml model to predict the urban expansion of this region in China we can prove the efectiveness of our labeling service and the accuracy of the service itself. Moreover, we will be analyzing the results found, to test if it aligns with general trends of the urban developement of the region to further test its our models accuracy. We hope that through the analyses we conduct in this project, we can promote people to use our service to aid communities. that live in rural areas across the world.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="data-cleaning">Data Cleaning<a class="hash-link" href="#data-cleaning" title="Direct link to heading">â€‹</a></h2><hr><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">import sklearn as sk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import numpy as np</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import pandas as pd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import rasterio, os, napari</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">from sklearn.model_selection import train_test_split</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">from sklearn.ensemble import RandomForestClassifier</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">from sklearn.svm import SVC</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">from sklearn.cluster import KMeans</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">from sklearn.preprocessing import StandardScaler</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">from sklearn.datasets import load_iris</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import functools</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>To begin, we conducted some data cleaning procedures with some replacement methods, removing any typos that could have occured in the labeling of urban and non_urban regions.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">labels = pd.Series(labels).replace(&#x27;non_urbn&#x27;,&#x27;non_urban&#x27;).replace(&#x27;non urban&#x27;,&#x27;non_urban&#x27;).replace(&#x27;Shapes&#x27;,&#x27;urban&#x27;).replace(&#x27;urban [1]&#x27;, &#x27;urban&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">labels.value_counts()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">labels = labels.replace(&#x27;non_urban&#x27;,&#x27;temp&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">labels = labels.replace(&#x27;urban&#x27;,&#x27;temp_2&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">labels = labels.replace(&#x27;temp&#x27;,&#x27;urban&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">labels = labels.replace(&#x27;temp_2&#x27;,&#x27;non_urban&#x27;) </span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="training-random-forest-classifier">Training Random Forest Classifier<a class="hash-link" href="#training-random-forest-classifier" title="Direct link to heading">â€‹</a></h2><p>Here we split the data with a training and a test set, with a 80% 20% split. This will allow us to train our model effectively, while still being able to test its performance.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain"> X_train, X_test, y_train, y_test = train_test_split(data,labels, test_size=0.2)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">%matplotlib inline</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import matplotlib.pyplot as plt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.style.use(&#x27;seaborn-whitegrid&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import numpy as np</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This is where we begin our hyperparameter optimization by testing a wide range of inputs and choosing the best performing input of the ones we tested. Much of the hyperparemeter tuning we performed here follows this logic, so for the sake of conciseness I won&#x27;t be reitering this for the rest of the parameter tuning. </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">scores_depth = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in range(1,50):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclf = RandomForestClassifier(max_depth=i, n_estimators=10, max_features=1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclf.fit(X_train, y_train)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    scores_depth.append(fclf.score(X_test, y_test))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>In this example it turned out the max depth was 25. In this example we added 1 to the location of the index of the highest score to compensate for the range we used starting at 1.</p><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/2697105594db4bae67695fb38933927411721f8e/image_1.png" alt="ml_image_1"></p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">max_score = max(scores_estimators)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">scores_estimators.index(max_score)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max_depth = scores_estimators.index(max_score)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max_depth += 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max_depth</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>25</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">scores_estimators = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in range(1,30):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclf = RandomForestClassifier(max_depth= max_depth, n_estimators=i, max_features=1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclf.fit(data, labels)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    scores_estimators.append(fclf.score(data, labels))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">plt.plot(range(1,30), scores_estimators)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.title(&quot;Number of Estimators over Accuracy Score&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.xlabel(&quot;Number of Estimators&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.ylabel(&quot;Accuracy in Percents&quot;);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/2697105594db4bae67695fb38933927411721f8e/image_2.png" alt="ml_image_2"></p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">max_score = max(scores_estimators)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max_estimators = scores_estimators.index(max_score)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max_estimators += 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max_estimators</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">score_features = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in range(1,10):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclf = RandomForestClassifier(max_depth = max_depth, n_estimators=max_estimators, max_features=i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclf.fit(X_train, y_train)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    score_features.append(fclf.score(X_test, y_test))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">plt.plot(range(1,10), score_features)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.title(&quot;Number of Max features over Accuracy Score&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.xlabel(&quot;Number of Max Features&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.ylabel(&quot;Accuracy in Percents&quot;);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/2697105594db4bae67695fb38933927411721f8e/image_3.png" alt="ml_image_3"></p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">max_score = max(score_features)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">score_features.index(max_score)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max_features = score_features.index(max_score)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max_features += 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">max_features</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>5</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">score_min_samples = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in range(2,10):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclf = RandomForestClassifier(max_depth = max_depth, n_estimators=max_estimators, max_features=max_features, min_samples_leaf = i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fclf.fit(X_train, y_train)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    score_min_samples.append(fclf.score(X_test, y_test))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">plt.plot(range(2,10), score_min_samples)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.title(&quot;Minimum Number of Samples Splits over Accuracy Score&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.xlabel(&quot;Minimum Number of Samples Splits&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.ylabel(&quot;Accuracy in Percents&quot;);</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/2697105594db4bae67695fb38933927411721f8e/image_4.png" alt="ml_image_4"></p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">max_score = max(score_min_samples )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">score_min_samples.index(max_score)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">min_samples = score_min_samples.index(max_score)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">min_samples += 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">min_samples</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here we test our values that we got from the  hyperparameter optimization and fit them into our final rRandomForestClassifier. Theoreticaly this model should be well suited to classify regions based on urban and non_urban regions with with similar geographic properties as the Xiong An New District we used for our classifcation model.</p><p>Testing our model on the training dataset we can see that we scored a significantly high score of 98.7% accuracy. This definitily promising to applying our models on other regions of Hebei that are like Xiong An New District. That being said it should be mentioned that our model had not shown to perform significantly well in other datasets that do not share similar geographic properties. For example, as our first datasets includes many areas that are marsh like, from the large rice fields in Xiong An New District, it may not perform as well in other regions that have dry soil. Noteabley, for our second datset it was observed that our model perform significantly worse the region of Xushui District that do not share the same agricultural farmlands as the Xiong An New District. Therefore, our model should only be used in consideration of geographic regions that mimic the region we used as it may be prone to decreases in accuracy if used in ill suited regions. </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">fclf = RandomForestClassifier(max_depth = max_depth, n_estimators=max_estimators, max_features=max_features, min_samples_leaf = min_samples)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fclf.fit(X_train, y_train)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fclf.score(X_test, y_test)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>0.987948551000602
]</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="analyses-of-prediction-model">Analyses of Prediction Model<a class="hash-link" href="#analyses-of-prediction-model" title="Direct link to heading">â€‹</a></h2><hr><p>Here we used our ml model we made in the previous step and processed the saved data we have in our testing_data/full_img/, already filled in the data_collection portion of this project. Although any tif files of the same dimensions as the images used for our train model could theoreticaly be used.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">from os import listdir</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">from os.path import isfile, join</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">onlyfiles = [f for f in listdir(full_directory) if isfile(join(full_directory, f))]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">model_predictions = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in onlyfiles:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    with rasterio.open(&#x27;testing_data/full_img/&#x27;  + i) as src:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #     print(src.shape)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        img = src.read()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#     img.flatten(order = &#x27;C&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        img_test = np.rollaxis(img.reshape(16,e_dims[1]*e_dims[2]),0,2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        model_predictions.append(fclf.predict(img_test))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here, we parse through the labels that we went acquired through our ml model. We then counted all the urban labels and and non_urban labels and created a ratio from these two value, where the length of urban labels was divided over the length of non_urban labels to get our desaired ratio.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">urban_ratio = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in model_predictions:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    urban_count = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for j in i:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if j == &#x27;urban&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            urban_count += 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#     print(urban_count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    non_urban_count  = len(i) - urban_count</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    urban_ratio.append(urban_count/non_urban_count)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">import datetime</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here we pull all the names of the images we used for our ml model so that we could extract the dates associated with each tif file.  We were able to extract the dates from the images by slicing their names which contained their associated dates and appended those dates to a list. We then formated and changed data type of the dates to datetime.date objects to better process the dates in our analyses.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">onlyfiles[0][6:16]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dates = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in onlyfiles:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dates.append(i[6:16])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x_values = [datetime.datetime.strptime(d,&quot;%Y-%m-%d&quot;).date() for d in dates]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x_values</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>This graph represents the raw distribution of the data between the years April 10, 2013 to present day. Notable outliers can be observed here.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">plt.plot(x_values, urban_ratio)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/10ab8cfba9286d05b11ad9db86757504eb67091d/graph_1.png" alt="analyses_image_1"></p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">import numpy as np</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import scipy.stats as st</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>The following lines are code to be able to be able to average out the urban ratios for every datapoint to be able to observe any discernable trend.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">year_list = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in x_values:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    year_list.append(i.year)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">years = np.unique(year_list)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here we initialize a dictionary to be able to classify the unique years in our datasets and set them as keys.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">year_avg = {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in years:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    year_avg[i] = []</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>We then fill these dictionaries with the values associated to every year.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">pd.Series(year_list).value_counts()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for count, value in enumerate(urban_ratio):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    year_avg[year_list[count]].append(value)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Bellow we average out the data, and print out the output. Each value bellow is chronological where the first entry is the average of year 2013, and the last being the average of year 2022.</p><p>Unfortunrately because of some extreem outliers that could be seen earlier in our data, some years have, such as April have higher than average scores.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">list_year_average = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in year_avg:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    list_year_average.append(np.mean(year_avg[i]))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">list_year_average</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>[0.8932386322805885,
0.5961964284060416,
2.541952400843471,
3.257714599207024,
1.249241606661275,
1.3375268946199286,
1.0263152629146564,
1.1877434043813473,
1.450091265543045,
2.5116910229645093]</p><p> To correct the discrepency in the data we decided to filter for any extreem outlier. As very few points scored higher than a 4, we decided to remove any outlier higher than this limit.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">urban_ratio_corrected  = urban_ratio.copy()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bad_index = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x_values_corrected = x_values.copy()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in urban_ratio_corrected:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   if i &gt; 4:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       outlier_index = urban_ratio_corrected.index(i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       bad_index.append(outlier_index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">count = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in bad_index:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   urban_ratio_corrected.pop(i - count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   x_values_corrected.pop(i - count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   count += 1</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>After removing any significant outliers the data took a form easier to interpret. The characteristics of the data seem to be ociliating respective to the beginings and ends of years. Additionaly there does seem to be a gradual increase to our urban score. It doesn&#x27;t seem very drastic but it does seem present.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">plt.plot(x_values_corrected, urban_ratio_corrected)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.title(&#x27;urban ratio over time&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.xlabel(&#x27;years&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.ylabel(&#x27;(urban/non urban) ratio&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.show()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/10ab8cfba9286d05b11ad9db86757504eb67091d/graph_2.png" alt="analyses_image_2"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="converting-dates-to-days">Converting dates to days<a class="hash-link" href="#converting-dates-to-days" title="Direct link to heading">â€‹</a></h2><p>TO further progress with the analyses of the data it was necessary to convert the values we have in our datetime.date objects to that of integers to be able to better process the data, and to test for further relationships it could have.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">import datetime</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p> Bellow we converted all the datetime.date objects to datetime.datetime using the timestop method in datetime.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">my_date = x_values_corrected[0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x_datetime = [datetime.datetime(i.year, i.month, i.day).timestamp() for i in x_values_corrected]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p> Once we had converted our object type to a datetime.datetime we then processed the tie in seconds to then be represented to time in minutes.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">x_datetime_start = min(x_datetime)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x_datetime_days = [(x - x_datetime_start)/(60 * 60 * 24) for x in x_datetime]</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="testing-for-positive-trends">Testing for Positive Trends<a class="hash-link" href="#testing-for-positive-trends" title="Direct link to heading">â€‹</a></h2><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">x_minutes_reshaped = np.array(x_datetime_days).reshape((-1, 1))</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Bellow we inputed our values into a linear regression model to see if our urban scores had any positive relationship over time. Analyzing our resulst we can see that there did seem to be positive coefficient of determination of 0.055, and a daily coefficient increase of 0.000236. COnverting the days into years yields a coefficient of a 0.086 increase of urban/non urban growth over a year. This certainly does seem to bode well for our classifcation service as an increase to urban/non urban growth indicates a growth in ubranization, as it should be considering that the Xiong An New District, the area from where our data is from is a new growing, and developing region in China that is suspected to have these kinda of growth.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">import numpy as np</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">from sklearn.linear_model import LinearRegression</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg = LinearRegression().fit(x_minutes_reshaped, urban_ratio_corrected)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg.score(x_minutes_reshaped, urban_ratio_corrected</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>0.05540008335192936</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">reg.intercept_</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>0.7142641939421813</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">reg.coef_</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>array(<!-- -->[0.000236]<!-- -->)</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">reg.coef_ * 365</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>array(<!-- -->[0.08614175]<!-- -->)</p><p>To visualized the relationship the linear relationship that our urban score has over time we displayed our information through a line graph. As our coeficients entailed, a positive coorelation can be observed to be illustrated in our graph through the red line. As iterated prior, this trend in the data indicating an increase in (urban labels/non urban labels) as time in days pass by (beginning from April 10, 2013) is indicative of urban expansion over time. </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">plt.plot(x_datetime_days, linear_relationship, label = &quot;line 1&quot;, color = &#x27;red&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.plot(x_datetime_days, urban_ratio_corrected)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.title(&#x27;urban ratio over time&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.xlabel(&#x27;days since April 10, 2013&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.ylabel(&#x27;(urban/non urban) ratio&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.show()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/10ab8cfba9286d05b11ad9db86757504eb67091d/graph_3.png" alt="analyses_image_3"></p><h3></h3><p>The following image is just a reiteration of our previouse data visualized but under a scater plot to observe the data under a different visual output. </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">!conda install --yes seaborn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x_series = pd.Series(x_datetime_days, name = &#x27;x_datetime_days&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">y_series = pd.Series(urban_ratio_corrected, name = &#x27;urban_ratio_corrected&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">df = pd.concat([x_series, y_series], axis=1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">import seaborn as sns</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sns.lmplot(x=&#x27;x_datetime_days&#x27;, y=&#x27;urban_ratio_corrected&#x27;, data = df, fit_reg=True, ci=0, n_boot=1000, line_kws={&#x27;color&#x27;: &#x27;red&#x27;})</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.title(&#x27;scatter plot of urban ratio over time&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.xlabel(&#x27;days since April 10, 2013&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.ylabel(&#x27;(urban/non urban) ratio&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.show()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/10ab8cfba9286d05b11ad9db86757504eb67091d/graph_4.png" alt="analyses_image_4"></p><p>To adress some of the concerns we had about the ocilation in the data we decided to test for seasonality in the data as there seemed to be a pattern of regular patterns in increases and decreases in the urban scores in the data. It was suspected that this ocilation could be linked to different tempeture and weathers that change depending on the seasons of the year. This would make sense as our use in the NDSI band to label our image was intended to be used diferenciate between vegetation and urban areas in our data. Therefore it would also be logical to conclude that much of our labels of non_urban areas would also be highly dense in vegetation as that would be the regions in our labeling service that were most visualy diferentiable and would thus have been classified as non_urban. As such, our non_urban label variable would be highly susceptible to seasonal changes such in weather, especialy tempeture.</p><p>To test for this theory we went ahead and detrended the data to see if we could observe any notable changes in pattern to the graph.</p><p>After detrending the data bellow, by removing any linear relationship between our two variables we plotted our data to test for seasonality. It can be observed that the data continuose to have a regular ocilating pattern that have regular intervals of increasing urban scores and decreasing urban scores, signifying possible trends to seasonality.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">deseasonlized = (urban_ratio_corrected - linear_relationship) + reg.intercept_</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.plot(x_datetime_days, deseasonlized)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.title(&#x27;urban ratio over time: detrended&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.xlabel(&#x27;days since April 10, 2013&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.ylabel(&#x27;(urban/non urban) ratio&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.show()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/10ab8cfba9286d05b11ad9db86757504eb67091d/graph_5.png"></p><p>Although to make sure that our prediction that our data included seasonal trends, we wanted to average out the data to see if we would still have that ocilation pattern that we have been observing thus far. </p><p>The processes to accomplish this was were simply to seperate all the dates to the months they pertained with, and to then average out their urban scores within datapoints of the same month.  </p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">month_list = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in x_values:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    month_list.append(i.month)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">months = np.unique(month_list)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>Here is where parsed through the months and saved their urban score.</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">months_avg_corrected = {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># year_avg.keys = years</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in months:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    months_avg_corrected[i] = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">months_avg_corrected</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">months_list_corrected = []</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in x_values_corrected:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    months_list_corrected.append(i.month)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">len(months_list_corrected)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">for count, value in enumerate(urban_ratio_corrected):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    months_avg_corrected[months_list_corrected[count]].append(value)</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">months_avg_corrected_2 = {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">for i in months_avg_corrected:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    months_avg_corrected_2[i] = np.mean(months_avg_corrected[i])</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p>After averaging the data by months it can be observed that the urban score decreases as it aproaches the hoter dates in Hebei (May 10 to September 19), the province which our region is located in, and increases as it aproaches the colder dates (November 25 to February 24).</p><div class="codeBlockContainer_I0IT theme-code-block"><div class="codeBlockContent_wNvx"><pre tabindex="0" class="prism-code language-text codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">month_names = [&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;March&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">year_avg_corrected = plt.plot(month_names,months_avg_corrected_2.values())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.title(&#x27;Urban Score Shift Over a Yearly Cycle&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.xlabel(&#x27;months&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.ylabel(&#x27;(urban/non urban) ratio&#x27;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plt.show()</span><br></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_wuS7 clean-btn">Copy</button></div></div><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/10ab8cfba9286d05b11ad9db86757504eb67091d/graph_6.png" alt="anaylyses_image_6"></p><p>Furthermore, meterological trends back up our findings.weatherspark, a weather related database has very similar graphical representations that align with our studies. Unfortunately our team does not have access to this data to compare our statistical findings to their. And because of the time constraint of our project we were unable to do further research into seasonality. So we can only reference visual representation as that is what time and resources permits in our project.</p><p><img src="https://raw.githubusercontent.com/IcanDXD/DSC_180_images/2090d5f67b5f53637858edf74602825c60845558/Average%20High%20and%20Low%20Temperature%20in%20Hebei.png" alt="analyses_image_7"></p><p>In summary, through the random forest classifier it was found that urban expansion seemed to take place between the years 2013 and 2022 in the Xiong An New District we gathered from the banded data collected in the data processing portion of our project. We were able to accomplish analyzing this trend by creating a scoring system using based on a frequency of urban to non urban ratio we gathered after classifying our data into these two cattegories. Once we processed the data and extracted the dates for these urban scores, we were able to graph the progression of the data over time, which revealed to have a positive coefficient of 0.055. These results can be interpreted as there being an increase of urban expansion over time as the urban score of urban labels/non_urban labels increased over time. Additionaly it was found out that, some additional trends such as the oscillation in the data distribution could be attributed to seasonal changes. Fortunately this oscilation did not affect the results of our finding in relation to our models positive coorelation between time and urban expansion.</p></div><div class="col col--2"><div class="tableOfContents_cNA8 thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#author-ivan-cano" class="table-of-contents__link toc-highlight">Author: Ivan Cano</a></li><li><a href="#date-382022" class="table-of-contents__link toc-highlight">Date: 3/8/2022</a></li><li><a href="#data-cleaning" class="table-of-contents__link toc-highlight">Data Cleaning</a></li><li><a href="#training-random-forest-classifier" class="table-of-contents__link toc-highlight">Training Random Forest Classifier</a></li><li><a href="#analyses-of-prediction-model" class="table-of-contents__link toc-highlight">Analyses of Prediction Model</a></li><li><a href="#converting-dates-to-days" class="table-of-contents__link toc-highlight">Converting dates to days</a></li><li><a href="#testing-for-positive-trends" class="table-of-contents__link toc-highlight">Testing for Positive Trends</a></li></ul></div></div></div></main></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/static-capstone-website/docs/intro">Tutorial</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items"><li class="footer__item"><a href="https://stackoverflow.com/questions/tagged/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Stack Overflow<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="footer__item"><a href="https://discordapp.com/invite/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>Discord<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/static-capstone-website/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">2022 GEEL. Built with Docusaurus.</div></div></div></footer></div>
<script src="/static-capstone-website/assets/js/runtime~main.21163b71.js"></script>
<script src="/static-capstone-website/assets/js/main.a793c94e.js"></script>
</body>
</html>