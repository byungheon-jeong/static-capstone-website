"use strict";(self.webpackChunkgeel_website=self.webpackChunkgeel_website||[]).push([[727],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return m}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=a.createContext({}),s=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(t),m=o,f=p["".concat(c,".").concat(m)]||p[m]||u[m]||r;return t?a.createElement(f,i(i({ref:n},d),{},{components:t})):a.createElement(f,i({ref:n},d))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=p;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=t[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},2997:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return d},default:function(){return p}});var a=t(7462),o=t(3366),r=(t(7294),t(3905)),i=["components"],l={},c=void 0,s={type:"mdx",permalink:"/static-capstone-website/about_us/alllbands",source:"@site/src/pages/about_us/alllbands.md",description:"Title All bands",frontMatter:{}},d=[{value:"Title: Data Collection and Filtering: All bands",id:"title-data-collection-and-filtering-all-bands",children:[],level:3},{value:"Author: Ivan Cano",id:"author-ivan-cano",children:[],level:3},{value:"Date: 3/5/2022",id:"date-352022",children:[],level:3}],u={toc:d};function p(e){var n=e.components,t=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h3",{id:"title-data-collection-and-filtering-all-bands"},"Title: Data Collection and Filtering: All bands"),(0,r.kt)("h3",{id:"author-ivan-cano"},"Author: Ivan Cano"),(0,r.kt)("h3",{id:"date-352022"},"Date: 3/5/2022"),(0,r.kt)("hr",null),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-import",metastring:"ee",ee:!0},"import geemap\nfrom datetime import datetime\nimport numpy as np\nimport rasterio\nimport matplotlib.pyplot as plt \nimport pandas as pd\nfrom datetime import date\nfrom datetime import timedelta\n")),(0,r.kt)("p",null,"The following method is used too filter the tif files based on their level of cloud interference in each respective image. Filtering by clouds is accomplished by passing an image, and checking for its value associated with its meteorological disturbance."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," `def cloudscore(image):\n        '''\n        Inner function for computing cloud score such that we can remove \n        bad images from the landsat collections we download.\n        Implementation in javascript can be found of Google Earth Engine \n        website under (landsat algorithms), translation to python by KH.\n        Further help from Nicholas Clinton at \n        https://urldefense.com/v3/__https://gis.stackexchange.com/questions/252685/filter-landsat-images-base-on-cloud-cover-over-a-region-of-interest*5Cn__;JQ!!LLK065n_VXAQ!zP9K-68-_oPkaNWFZdbTYYnai85ggL4j3FhdqssLkim-RneBr2NqD6Ka4fu6yw-v$         '''\n        cloud = ee.Algorithms.Landsat.simpleCloudScore(image).select('cloud')\n        cloudiness = cloud.reduceRegion(ee.Reducer.mean(),\n                                        geometry=region,\n                                        scale=30)\n        image = image.set(cloudiness)\n        return image\n")),(0,r.kt)("p",null,"Authentification requirements to access and initialize the google engine library"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-#",metastring:"Trigger the authentication flow",Trigger:!0,the:!0,authentication:!0,flow:!0},"ee.Authenticate()\n\n# Initialize the library\nee.Initialize()\n")),(0,r.kt)("p",null,"bbox includess the coordinates for the bounding box we will be using for our image. Each list includes a longitude and latitude for each of the quadrants of our bounding box."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bbox = [(115.90619263363669, 38.910654401256274),\n(116.12214264584372, 38.910654401256274),\n(116.12214264584372, 38.988885740039514),\n(115.90619263363669, 38.988885740039514)]\n")),(0,r.kt)("p",null,"In order to have a wide range of data points, in the form of pixels, we applied the following bands to train our model.\nBands B1 through B11 track wavelengths on the electromagnetic spectrum, and ''SAA','SZA','VAA','VZA', are values generated by shadows casted throughout various points in the day."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bands = ['B1','B2','B3','B4','B5','B6','B7','B8','B9','B10','B11','QA_RADSAT','SAA','SZA','VAA','VZA']\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"start_date = datetime(2013,3,18)\n\nend_date = datetime(2022,2,3)\n\nregion = ee.Geometry.Polygon(bbox)\n\ncollection = ee.ImageCollection('LANDSAT/LC08/C02/T1_TOA').filterDate(start_date,end_date).filterBounds(region)\n\ncloud_tol=100\ncollection= collection.map(algorithm=cloudscore).filter(ee.Filter.lt('cloud', cloud_tol))\n")),(0,r.kt)("p",null,"Because of the nature of satelite images, many of them end up either clipped or corruption. This is due to a combination of instrament error and faulty correction of the shifts in space as the satelites move. Therefore as there is no parameter to test for corrupted and clipped images, a manual filter was conducted where faulty images were noted to be excluded, which were of the dates listed bellow."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bad_dates = ['2013-04-05',\n'2013-06-13',\n '2013-06-29',\n '2013-07-31',\n '2013-09-17',\n '2013-10-19',\n '2013-12-06',\n '2014-01-07',\n '2014-02-08',\n '2014-03-12',\n '2014-05-31',\n '2014-06-16',\n '2014-08-03',\n '2014-11-07',\n '2014-12-09',\n '2015-01-26',\n '2015-06-19',\n '2015-07-21',\n '2015-09-23',\n '2016-03-17',\n '2016-04-02',\n '2016-07-07',\n '2016-07-23',\n '2016-08-08',\n '2016-09-09',\n '2016-09-25',\n '2017-02-16',\n '2017-03-20',\n '2017-06-24',\n '2017-08-11',\n '2017-09-12',\n '2017-10-14',\n '2018-01-18',\n '2018-02-19',\n '2018-05-10',\n '2018-07-29',\n '2018-09-15',\n '2018-10-17',\n '2018-12-20',\n '2019-02-22',\n '2019-04-11',\n '2019-07-16',\n '2019-10-20',\n '2020-02-09',\n '2020-05-15',\n '2020-07-02',\n '2021-01-26',\n '2021-04-16',\n '2021-08-06',\n '2021-08-22',\n '2021-09-07',\n '2021-09-23',\n '2021-10-25']\n\nfrom datetime import date\n\nlist_set = []\nfor i in range(len(bad_dates)):   \n    datetime_object = date.fromisoformat(bad_dates[i])\n    start = datetime_object + timedelta(days=1)\n    end = datetime_object - timedelta(days=1)\n    \n    list_set.append((str(start), str(end)))\n\nfor i in range(len(list_set)):\n    collection = collection.filter(ee.Filter.date(list_set[i][0], list_set[i][1]).Not())\n")),(0,r.kt)("p",null,"Selects all images based on previously implimented filters includeing, cloud, date, and band selections."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"collection = collection.select(bands)\ncollection_list = collection.toList(collection.size())\n\ncollection_size = collection_list.size().getInfo()\ndates = geemap.image_dates(collection, date_format='YYYY-MM-dd').getInfo()\n")),(0,r.kt)("p",null,"The following code downloads all images into the local machine."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'    for i, date in enumerate(dates[:]):\n        \n        if date in bad_dates:\n            continue\n            \n        image = ee.Image(collection_list.get(i))\n\n\n        new_image = image.select(bands)\n\n        geemap.ee_export_image(new_image, filename = "testing_data/full_img/China_{}.tif".format(date), scale = 100, region = region, file_per_band = False)\n\n        s_imgs.append(new_image)\n')))}p.isMDXComponent=!0}}]);